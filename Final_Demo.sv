
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Final_Demo(

	//////////// CLOCK //////////
	input 		          		REF_CLK,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     		RST_n,
	input 		     		start_button,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    LiDAR_RX_1,
	inout 		    LiDAR_TX_1,
	// inout 		    [33:22]		GPIO_0,
	inout 		    		    BOOT_RX,
	inout 		    [20:2]		GPIO_0,
	inout 		    piezo_out,
	inout 		    piezo_out_n,
	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    LiDAR_RX_2,
	inout 		    LiDAR_TX_2,
	inout 		    [35:2]		GPIO_1
	//TODO: figure out which GPIO will be used for UART RX
);

///////////////////////////////////////
// Create defines for external regs //
/////////////////////////////////////
localparam LED_reg    	= 32'h0000C000;
localparam SW_reg    	= 32'h0000C001;
localparam BMP_CTL    	= 32'h0000C008;     // Has the following bit mapping: {add_fnt,fnt_indx[5:0],2’b00,add_img,rem_img,image_index[4:0]}
localparam BMP_XLOC   	= 32'h0000C009;     // X-location (in pixels) of upper left corner of BMP image (write to this before writing to BMP_CTL)
localparam BMP_YLOC   	= 32'h0000C00A;     // Y-location (in pixels) of upper left corner of BMP image (write to this before writing to BMP_CTL)
localparam BMP_STAT   	= 32'h0000C00B;     // A read from this returns {15’h0000,busy} Your code should poll for not busy before any write to BMP_CTL.
localparam USER_KEYS  	= 32'h0000C00C;     // A read from this returns {15'b0, start_button_pressed}
localparam PIEZO_REG  	= 32'h0000C00D;     // A write to this reg starts the buzzer {13’h0000,piezo_index[1:0],start_buzzer}
localparam USER_1_DIST 	= 32'h0000C00E;     // A read from this returns user 1 lidar Distance [15:0]
localparam USER_2_DIST 	= 32'h0000C00F;     // A read from this returns user 2 lidar Distance [15:0]

`include "common_params.inc"

//=======================================================
//  REG/WIRE declarations
//=======================================================

//synchronized reset
logic rst_n;

// cpu signals
logic [31:0] addr;
logic re;
logic we;
logic [31:0] wdata;
logic [31:0] rdata;

// bootloader signals
logic boot_we;
logic [14:0] boot_waddr;
logic [31:0] boot_wdata;

//start button signals
logic start_button_pressed;
reg [2:0] start_button_sync;
logic clear_register;

//LiDAR signals
logic [15:0] Distance_1;
logic [15:0] Distance_2;

// 7-segment output
logic [15:0] output_value;

//buzzer signals
logic [1:0] piezo_indx;
logic start_buzzer;

//VGA Signals
logic [9:0] xpix;						// current X coordinate of VGA
logic [8:0] ypix;						// current Y coordinate of VGA
logic [18:0] VGA_raddr;				    // address into videoMem for reads (comes from VGA_timing)
logic [5:0]  VGA_rdata;					// 6-bit color
logic [18:0] VGA_waddr;				    // write address to videoMem
logic [5:0]  VGA_wdata;					// write data to videoMem
logic VGA_we;
logic VGA_re;

//BMP signals
logic [4:0] image_indx;
logic [9:0] xloc;
logic [8:0] yloc;
logic add_img,add_fnt, rem_img;
logic [5:0] fnt_indx;

//LED signalas
logic [9:0]	LEDR_imm;

logic boot_en, boot_done;

assign boot_en = SW[0];

//=======================================================
//  instantiate modules
//=======================================================
piezo iPIEZO(.clk(clk), .rst_n(rst_n), .start(start_buzzer), .piezo_indx(piezo_indx), .piezo(piezo_out), .piezo_n(piezo_out_n));

lidar_intf iLIDAR1(.clk(clk), .rst_n(rst_n), .RX(LiDAR_TX_1), .TX(LiDAR_RX_1), .Distance(Distance_1));

lidar_intf iLIDAR2(.clk(clk), .rst_n(rst_n), .RX(LiDAR_TX_2), .TX(LiDAR_RX_2), .Distance(Distance_2));

PLL iPLL(.refclk(REF_CLK), .rst(~RST_n),.outclk_0(clk),.outclk_1(VGA_CLK),
         .locked(pll_locked));

rst_synch iRST(.clk(clk),.RST_n(RST_n), .pll_locked(pll_locked), .rst_n(rst_n));

VGA_timing iVGATM(.clk25MHz(VGA_CLK), .rst_n(rst_n), .VGA_BLANK_N(VGA_BLANK_N),
				.VGA_HS(VGA_HS),.VGA_SYNC_N(VGA_SYNC_N), .VGA_VS(VGA_VS),
				.xpix(xpix), .ypix(ypix), .addr_lead(VGA_raddr));

videoMem iVM(.clk(clk),.we(VGA_we),.waddr(VGA_waddr),.wdata(VGA_wdata),.raddr(VGA_raddr),.rdata(VGA_rdata));
assign VGA_R = {VGA_rdata[5:4],6'b000000};
assign VGA_G = {VGA_rdata[3:2],6'b000000};
assign VGA_B = {VGA_rdata[1:0],6'b000000};

PlaceBMP iPLACEBMP(.clk(clk),.rst_n(rst_n),.add_fnt(add_fnt),.fnt_indx(fnt_indx),
           .add_img(add_img),.rem_img(rem_img),.image_indx(image_indx),
           .xloc(xloc),.yloc(yloc),.waddr(VGA_waddr),.wdata(VGA_wdata),.we(VGA_we),
		   .busy(busy));

cpu iCPU(.clk(clk), .rst_n(rst_n), .wdata(wdata), .we(we), .addr(addr), .re(re), .rdata(rdata),
		 .boot_we(boot_we), .boot_waddr(boot_waddr), .boot_wdata(boot_wdata), .boot_en(boot_en));

SEG7_LUT_6 	i7SEG(.oSEG0(HEX0),.oSEG1(HEX1),.oSEG2(HEX2),.oSEG3(HEX3),
				 .oSEG4(HEX4),.oSEG5(HEX5), .iDIG({8'h00, output_value}));

UART_Boot iBOOT(.clk(clk), .rst_n(rst_n), .RX(BOOT_RX), .we(boot_we), .waddr(boot_waddr), .wdata(boot_wdata), .boot_en(boot_en), .boot_done(boot_done));
//bootloader iBOOT(.clk(clk), .rst_n(rst_n), .debug(1'b1), .RX(RX), .addr(boot_waddr), .data(boot_wdata));

//=======================================================
//  Structural coding
//=======================================================

//detect the button being released
always_ff @(posedge clk, negedge rst_n) begin
	if(~rst_n)  
		start_button_pressed <= 0;
	else if(clear_register)
		start_button_pressed <= 0;
  	else begin
		if(~start_button_sync[2] && start_button_sync[1])
			start_button_pressed <= 1;
  	end
end

//sync start button registers
always_ff @(posedge clk, negedge rst_n) begin
	if(!rst_n) begin
        start_button_sync <= 0;
    end
    else begin 
        start_button_sync[0] <= start_button;
        start_button_sync[1] <= start_button_sync[0];
        start_button_sync[2] <= start_button_sync[1];
    end
end


//seven segment output
always_ff @(posedge clk, negedge rst_n) begin
	if(!rst_n) 
		output_value <= 16'h6969;
	else if(boot_en) begin
		output_value <= {1'b0,boot_waddr};
	end
	else if(SW[3])
		output_value <= Distance_1;
	else
		output_value <= Distance_2;
end

//write register
always_ff @(posedge clk, negedge rst_n) begin
	if (!rst_n) begin
		add_fnt <= '0;
		fnt_indx <= '0;
		add_img <= '0;
		image_indx <= '0;
		xloc <= '0;
		yloc <= '0;
		start_buzzer <= '0;
		piezo_indx <= '0;
		LEDR_imm <= '0;
		
	end
	else begin
		if (we && addr == BMP_CTL) begin
			add_fnt <= wdata[15];
			fnt_indx <= wdata[14:9];
			add_img <= wdata[6];
			rem_img <= wdata[5];
			image_indx <= wdata[4:0];
		end
		else if (we && addr === BMP_XLOC)
			xloc <= wdata[9:0];
		else if (we && addr === BMP_YLOC)
			yloc <= wdata[8:0];
		else if (we && addr === PIEZO_REG) begin
			start_buzzer <= wdata[0];
			piezo_indx <= wdata[2:1];
		end
		else if (we && addr === LED_reg)
			LEDR_imm <= wdata[9:0];
		// else begin
		// 	add_fnt <= '0;
		// 	add_img <= '0;
		// end

	end
end

assign LEDR = {LEDR_imm[8:0], boot_done};
//read register
assign rdata = 	 	(re && addr === SW_reg) ? {16'h0000,6'h00,SW}:
					(re && addr === BMP_CTL) ? {16'h0000,add_fnt, fnt_indx, 2'b00, add_img, rem_img, image_indx} :
					(re && addr === BMP_XLOC) ? {16'h0000,6'b0, xloc} :
					(re && addr === BMP_YLOC) ? {16'h0000,7'b0, yloc} :
					(re && addr === BMP_STAT) ? {16'h0000,15'b0, busy} :
					(re && addr === USER_KEYS) ? {16'h0000,15'b0, start_button_pressed} :
					(re && addr === USER_1_DIST) ? {16'h0000,Distance_1} :
					(re && addr === USER_2_DIST) ? {16'h0000,Distance_2} : 'x;

assign clear_register = ((re && addr === USER_KEYS) && (start_button_pressed));

endmodule